<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <!-- Lock zoom on the whole page -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>Ring Size Finder</title>
  <style>
    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;                 /* no page scroll */
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      background: #2e555a;
      color: #111;
      touch-action: manipulation;
      overscroll-behavior: none;
    }

    .frame {
      min-height: 100dvh;               /* fill viewport, avoid mobile bounce */
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 8px;                     /* tiny edge padding to prevent clipping */
    }

    .step {
      width: min(98vw, 1200px);
      background: #fff6f6;
      padding: 12px 14px 14px;
      border: 1px solid #ddd;
      border-radius: 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.05);
      position: relative;
    }

    .title { margin: 0 0 .4rem; text-align: center; }
    .subtitle { margin: .2rem 0 .6rem; text-align: center; }

    /* Shared stage (white box) */
    .stage {
      position: relative;
      width: 100%;
      max-width: 1200px;
      height: clamp(300px, 50vh, 500px);  /* card calibration height */
      margin: 6px auto 8px;
      background: #fff;
      border: 1px solid #ffb3b3;
      border-radius: 12px;
      overflow: hidden;
      display: grid;
      place-items: center;
    }

    /* Ring sizer white box: shorter to remove extra top/bottom space */
    #sizerArea.stage {
      height: clamp(240px, 40vh, 360px);
    }

    .controls {
      position: relative;
      z-index: 5;                       /* ensure buttons are always clickable */
      margin: .45rem 0 0;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: .5rem;
      flex-wrap: wrap;
    }
    .btn {
      padding: .55rem 1rem;
      font-size: 1rem;
      border-radius: 10px;
      border: 1px solid #ddd;
      background: #f3f3f3;
      cursor: pointer;
      user-select: none;
      -webkit-user-select: none;
    }
    .btn:hover { background: #e9e9e9; }

    .segmented {
      display: inline-flex;
      border: 1px solid #ddd;
      border-radius: 10px;
      overflow: hidden;
      background: #f3f3f3;
    }
    .segmented button {
      border: 0;
      background: transparent;
      padding: .5rem .9rem;
      cursor: pointer;
      font-size: .95rem;
    }
    .segmented button + button {
      border-left: 1px solid #d0d0d0;
    }
    .segmented button.active { background: #fff; font-weight: 700; }

    /* Calibration shapes */
    #creditCard {
      width: 380px;                      /* JS may override */
      aspect-ratio: 85.6 / 53.98;
      background: #e6e6e6;
      border: 2px solid #111;
      border-radius: 16px;
      box-shadow: inset 0 0 0 1px rgba(0,0,0,0.06);
      pointer-events: none;
    }
    #coinCircle {
      width: 170px;                      /* visual start size; user adjusts */
      height: 170px;
      border-radius: 50%;
      background: #e6e6e6;
      border: 2px solid #111;
      box-shadow: inset 0 0 0 1px rgba(0,0,0,0.06);
      pointer-events: auto;
      touch-action: none;
      cursor: grab;
    }

    /* Ring sizer circle */
    #sizerCircle {
      width: 100px;
      height: 100px;
      border: 3px dotted #000;
      border-radius: 50%;
      background: rgba(211,211,211,0.5);
      position: relative;                /* centered by grid parent */
      touch-action: none;
      cursor: grab;
      box-shadow: 0 0 6px rgba(0,0,0,0.15);
    }

    .diameter-line { margin-top: 4px; font-weight: 700; text-align: center; }

    /* Size cards */
    .sizes-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      margin-top: 6px;
    }
    .size-card {
      background: #ffffff;
      border: 1px solid #e6e6e6;
      border-radius: 12px;
      box-shadow: 0 1px 6px rgba(0,0,0,0.05);
      padding: 8px 6px;
      text-align: left;
    }
    .size-card .label {
      font-size: .72rem;
      letter-spacing: .04em;
      text-transform: uppercase;
      color: #777;
      margin-bottom: 4px;
    }
    .size-card .value {
      font-size: 1.25rem;
      font-weight: 800;
      color: #111;
      line-height: 1.05;
    }

    /* Mobile-only tweaks */
    @media (max-width: 520px) {
      .frame { padding: 0; }
      .step { width: 100vw; border-radius: 0; padding: 10px 10px 12px; }
      .stage { width: 100%; max-width: none; margin: 4px 0 6px; }
      .stage { height: clamp(280px, 48vh, 420px); }
      #sizerArea.stage { height: clamp(220px, 38vh, 340px); }
      .btn { min-width: 44px; padding: .6rem 1rem; font-size: 1.05rem; border-radius: 12px; }
      .mode-switch { display: none; } /* Coin-only UX on mobile */
    }
  </style>
</head>
<body>
  <main class="frame">

    <!-- STEP 1: Calibration -->
    <section class="step" id="step1">
      <h2 class="title" data-i18n="step1_title">Step 1: Calibrate Your Screen</h2>
      <p class="subtitle" data-i18n="step1_subtitle">Choose your method, then resize to match the real object.</p>

      <!-- Desktop mode switch (hidden on mobile) -->
      <div class="controls mode-switch" style="margin-bottom:.35rem">
        <div class="segmented" role="tablist" aria-label="Calibration method">
          <button id="modeCoinBtn" class="active" role="tab" aria-selected="true" type="button" data-i18n="mode_coin">Coin</button>
          <button id="modeCardBtn" role="tab" aria-selected="false" type="button" data-i18n="mode_card">Credit card</button>
        </div>
      </div>

      <!-- COIN MODE (mobile default) -->
      <div id="coinMode">
        <div class="controls" style="margin-top:.15rem">
          <div id="coinSelector" class="segmented" aria-label="Coin type">
            <button id="coinEURBtn" class="active" data-mm="23.25" type="button">€1</button>
            <button id="coinUKBtn"  data-mm="22.5"  type="button">£1</button>
            <button id="coinUSBtn"  data-mm="24.26" type="button">US 25¢</button>
            <button id="coinCADBtn" data-mm="23.88" type="button">CA 25¢</button>
          </div>
        </div>

        <div class="stage" id="coinStage">
          <div id="coinCircle"></div>
        </div>

        <div class="controls">
          <button class="btn" id="coinSmaller" type="button" data-i18n="minus">−</button>
          <button class="btn" id="coinLarger"  type="button" data-i18n="plus">+</button>
        </div>

        <div class="controls" style="margin-top:.45rem">
          <button class="btn" id="skipBtn1" type="button" data-i18n="skip">Skip calibration</button>
          <button class="btn" id="nextBtn1" type="button" data-i18n="next">Next</button>
        </div>
      </div>

      <!-- CARD MODE (desktop default) -->
      <div id="cardMode" style="display:none">
        <p class="subtitle" style="margin-top:.25rem" data-i18n="card_hint">Match the long edge of a credit card.</p>
        <div class="stage" id="cardArea">
          <div id="creditCard"></div>
        </div>
        <div class="controls">
          <button class="btn" id="cardSmaller" type="button" data-i18n="minus">−</button>
          <button class="btn" id="cardLarger"  type="button" data-i18n="plus">+</button>
        </div>
        <div class="controls" style="margin-top:.45rem">
          <button class="btn" id="skipBtn2" type="button" data-i18n="skip">Skip calibration</button>
          <button class="btn" id="nextBtn2" type="button" data-i18n="next">Next</button>
        </div>
      </div>
    </section>

    <!-- STEP 2: Ring sizer -->
    <section class="step" id="step2" style="display:none;">
      <h2 class="title" data-i18n="step2_title">Step 2: Measure Your Ring Size</h2>
      <p class="subtitle" data-i18n="step2_subtitle">Place your ring on the screen and match the circle to the <strong>inner edge</strong>.</p>

      <div class="stage" id="sizerArea">
        <div id="sizerCircle"></div>
      </div>

      <div class="controls" style="margin-top:.2rem">
        <button class="btn" id="circleSmaller" type="button" data-i18n="minus">−</button>
        <button class="btn" id="circleLarger"  type="button" data-i18n="plus">+</button>
        <button class="btn" id="reset18"       type="button" data-i18n="reset18">Reset to 18 mm</button>
      </div>

      <div class="diameter-line" id="diameterOut" aria-live="polite">Diameter: — mm</div>

      <div class="sizes-grid" aria-live="polite">
        <div class="size-card"><div class="label">US</div><div class="value" id="usValue">—</div></div>
        <div class="size-card"><div class="label">UK</div><div class="value" id="ukValue">—</div></div>
        <div class="size-card"><div class="label">EU</div><div class="value" id="euValue">—</div></div>
      </div>
    </section>

  </main>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      /* ========= I18N (EN + FI) ========= */
      const I18N = {
        en: {
          step1_title: "Step 1: Calibrate Your Screen",
          step1_subtitle: "Choose your method, then resize to match the real object.",
          mode_coin: "Coin",
          mode_card: "Credit card",
          minus: "−",
          plus: "+",
          skip: "Skip calibration",
          next: "Next",
          card_hint: "Match the long edge of a credit card.",
          step2_title: "Step 2: Measure Your Ring Size",
          step2_subtitle: "Place your ring on the screen and match the circle to the <strong>inner edge</strong>.",
          reset18: "Reset to 18 mm",
          diameter_prefix: "Diameter",
          max_us13: "(Max US 13)",
          min_us3: "(Min US 3)"
        },
        fi: {
          step1_title: "Vaihe 1: Kalibroi näyttö",
          step1_subtitle: "Valitse menetelmä ja säädä vastaamaan oikeaa esinettä.",
          mode_coin: "Kolikko",
          mode_card: "Pankkikortti",
          minus: "−",
          plus: "+",
          skip: "Ohita kalibrointi",
          next: "Seuraava",
          card_hint: "Sovita pankkikortin pitkään reunaan.",
          step2_title: "Vaihe 2: Mittaa sormuskokosi",
          step2_subtitle: "Aseta sormus näytölle ja säädä ympyrä vastaamaan <strong>sisäreunaa</strong>.",
          reset18: "Palauta 18 mm",
          diameter_prefix: "Halkaisija",
          max_us13: "(Enintään US 13)",
          min_us3: "(Vähintään US 3)"
        }
      };

      const params = new URLSearchParams(location.search);
      const urlLang = (params.get('lang') || '').toLowerCase();
      const storedLang = (localStorage.getItem('ringSizer.lang') || '').toLowerCase();
      const browserLang = (navigator.language || 'en').split('-')[0].toLowerCase();
      let LANG = ['en','fi'].includes(urlLang) ? urlLang
               : ['en','fi'].includes(storedLang) ? storedLang
               : (browserLang === 'fi' ? 'fi' : 'en');

      function t(key){ return (I18N[LANG] && I18N[LANG][key]) || I18N.en[key] || key; }
      function applyI18n(){
        document.documentElement.lang = LANG;
        document.querySelectorAll('[data-i18n]').forEach(el=>{
          const key = el.getAttribute('data-i18n');
          if (key === 'step2_subtitle') el.innerHTML = t(key);
          else el.textContent = t(key);
        });
        if (window._updateDiameterLine) window._updateDiameterLine();
      }
      applyI18n();

      /* ========= EXISTING APP LOGIC ========= */
      const DEFAULT_PX_PER_MM = 96 / 25.4; // fallback
      const IS_MOBILE = window.matchMedia('(max-width: 520px)').matches;

      let pxPerMM = null;
      let MIN_DIAMETER_PX = 0;
      let MAX_DIAMETER_PX = Infinity;

      // Mode switching (desktop can toggle; mobile defaults to coin)
      const modeCoinBtn = document.getElementById('modeCoinBtn');
      const modeCardBtn = document.getElementById('modeCardBtn');
      const coinMode = document.getElementById('coinMode');
      const cardMode = document.getElementById('cardMode');

      function setMode(mode) {
        const coinActive = (mode === 'coin');
        coinMode.style.display = coinActive ? 'block' : 'none';
        cardMode.style.display = coinActive ? 'none' : 'block';
        if (modeCoinBtn && modeCardBtn) {
          modeCoinBtn.classList.toggle('active', coinActive);
          modeCardBtn.classList.toggle('active', !coinActive);
          modeCoinBtn.setAttribute('aria-selected', coinActive ? 'true' : 'false');
          modeCardBtn.setAttribute('aria-selected', !coinActive ? 'true' : 'false');
        }
      }

      // Desktop default: card; Mobile default: coin
      setMode(IS_MOBILE ? 'coin' : 'card');
      if (modeCoinBtn && modeCardBtn) {
        modeCoinBtn.addEventListener('click', () => setMode('coin'));
        modeCardBtn.addEventListener('click', () => setMode('card'));
      }

      // ===== Coin calibration =====
      const coinSelector = document.getElementById('coinSelector');
      const coinCircle   = document.getElementById('coinCircle');
      const coinSmaller  = document.getElementById('coinSmaller');
      const coinLarger   = document.getElementById('coinLarger');

      // Default coin: €1
      let coinTargetMM = 23.25;
      let coinPx = IS_MOBILE ? 150 : 170;

      function renderCoinUI() {
        [...coinSelector.querySelectorAll('button')].forEach(btn => {
          const mm = parseFloat(btn.dataset.mm);
          btn.classList.toggle('active', Math.abs(mm - coinTargetMM) < 0.001);
        });
        coinCircle.style.width = coinPx + 'px';
        coinCircle.style.height = coinPx + 'px';
      }

      coinSelector.addEventListener('click', (e) => {
        const btn = e.target.closest('button');
        if (!btn) return;
        e.preventDefault();
        const newMM = parseFloat(btn.dataset.mm);
        if (isNaN(newMM)) return;
        coinPx = Math.max(60, Math.min(1000, Math.round(coinPx * (newMM / coinTargetMM))));
        coinTargetMM = newMM;
        renderCoinUI();
      });

      coinSmaller.addEventListener('click', (e) => {
        e.preventDefault();
        coinPx = Math.max(60, coinPx - 6);
        renderCoinUI();
      });
      coinLarger.addEventListener('click', (e) => {
        e.preventDefault();
        coinPx = Math.min(1000, coinPx + 6);
        renderCoinUI();
      });

      // Drag-to-resize for the coin circle
      let coinDragging = false;
      let coinStartX = 0;
      coinCircle.addEventListener('pointerdown', (e) => {
        coinDragging = true;
        coinStartX = e.clientX;
        coinCircle.setPointerCapture(e.pointerId);
      });
      coinCircle.addEventListener('pointermove', (e) => {
        if (!coinDragging) return;
        const dx = e.clientX - coinStartX;
        coinPx = Math.max(60, Math.min(1000, coinPx + dx));
        coinStartX = e.clientX;
        renderCoinUI();
      });
      coinCircle.addEventListener('pointerup', () => { coinDragging = false; });

      // ===== Card calibration (desktop) =====
      const creditCard  = document.getElementById('creditCard');
      let cardWidthPx   = IS_MOBILE ? 320 : 380;

      function applyCardWidth(px) { creditCard.style.width = px + 'px'; }
      applyCardWidth(cardWidthPx);

      document.getElementById('cardSmaller').addEventListener('click', (e) => {
        e.preventDefault();
        cardWidthPx = Math.max(120, cardWidthPx - 10);
        applyCardWidth(cardWidthPx);
      });
      document.getElementById('cardLarger').addEventListener('click', (e) => {
        e.preventDefault();
        cardWidthPx = Math.min(2400, cardWidthPx + 10);
        applyCardWidth(cardWidthPx);
      });

      // ===== Ring sizer data =====
      const sizerEl     = document.getElementById('sizerCircle');
      const sizerArea   = document.getElementById('sizerArea');
      const diameterOut = document.getElementById('diameterOut');
      const usValue     = document.getElementById('usValue');
      const ukValue     = document.getElementById('ukValue');
      const euValue     = document.getElementById('euValue');

      let diameterPx = 0;
      let dragging = false;
      let startX = 0;

      const sizeChart = [
        { mm: 14.1, us: "3",   uk: "F",  eu: "44"   },
        { mm: 14.5, us: "3.5", uk: "G",  eu: "45.5" },
        { mm: 14.9, us: "4",   uk: "H",  eu: "46.5" },
        { mm: 15.3, us: "4.5", uk: "I",  eu: "48"   },
        { mm: 15.7, us: "5",   uk: "J",  eu: "49"   },
        { mm: 16.1, us: "5.5", uk: "K",  eu: "50.5" },
        { mm: 16.5, us: "6",   uk: "L",  eu: "51.5" },
        { mm: 16.9, us: "6.5", uk: "M",  eu: "53"   },
        { mm: 17.3, us: "7",   uk: "N",  eu: "54.5" },
        { mm: 17.7, us: "7.5", uk: "O",  eu: "56"   },
        { mm: 18.1, us: "8",   uk: "P",  eu: "57"   },
        { mm: 18.5, us: "8.5", uk: "Q",  eu: "58.5" },
        { mm: 18.9, us: "9",   uk: "R",  eu: "60"   },
        { mm: 19.4, us: "9.5", uk: "S",  eu: "61"   },
        { mm: 19.8, us: "10",  uk: "T",  eu: "62.5" },
        { mm: 20.2, us: "10.5",uk: "U",  eu: "63.5" },
        { mm: 20.6, us: "11",  uk: "V",  eu: "65"   },
        { mm: 21.0, us: "11.5",uk: "W",  eu: "66"   },
        { mm: 21.4, us: "12",  uk: "X",  eu: "67.5" },
        { mm: 21.8, us: "12.5",uk: "Y",  eu: "69"   },
        { mm: 22.2, us: "13",  uk: "Z",  eu: "70"   }
      ];

      const MIN_DIAMETER_MM = sizeChart[0].mm;                        // 14.1 (US 3)
      const MAX_DIAMETER_MM = sizeChart[sizeChart.length - 1].mm;     // 22.2 (US 13)

      function nearestSize(mm) {
        return sizeChart.reduce((prev, curr) =>
          Math.abs(curr.mm - mm) < Math.abs(prev.mm - mm) ? curr : prev
        );
      }

      function stageLimitPx() {
        const rect = sizerArea.getBoundingClientRect();
        const padding = 24; // px margin from the edge
        return Math.max(30, Math.min(rect.width, rect.height) - padding);
      }

      function hardMaxPx() {
        const capByChart = MAX_DIAMETER_PX;   // tied to US 13 after calibration
        const capByStage = stageLimitPx();
        return Math.max(30, Math.min(capByChart, capByStage));
      }

      function hardMinPx() {
        // Minimum is the chart min converted to px; never less than some small visual floor
        return Math.max(30, MIN_DIAMETER_PX || 0);
      }

      function setDefaultDiameter(targetMM) {
        if (!pxPerMM) {
          const stored = parseFloat(localStorage.getItem('pxPerMM') || '0');
          pxPerMM = stored > 0 ? stored : DEFAULT_PX_PER_MM;
        }
        // ensure min/max px are known
        if (!isFinite(MIN_DIAMETER_PX) || MIN_DIAMETER_PX <= 0) {
          MIN_DIAMETER_PX = MIN_DIAMETER_MM * pxPerMM;
        }
        if (!isFinite(MAX_DIAMETER_PX) || MAX_DIAMETER_PX <= 0) {
          MAX_DIAMETER_PX = MAX_DIAMETER_MM * pxPerMM;
        }
        diameterPx = Math.round(pxPerMM * targetMM);
        diameterPx = Math.max(hardMinPx(), Math.min(hardMaxPx(), diameterPx));
      }

      // expose so i18n can refresh the line
      window._updateDiameterLine = function(){
        const mm = (diameterPx / (pxPerMM || DEFAULT_PX_PER_MM)).toFixed(1);
        const match = nearestSize(parseFloat(mm));
        let notes = [];
        if (Math.abs(diameterPx - hardMinPx()) < 0.5) notes.push(t('min_us3'));
        if (Math.abs(diameterPx - hardMaxPx()) < 0.5) notes.push(t('max_us13'));
        diameterOut.textContent = `${t('diameter_prefix')}: ${mm} mm${notes.length ? ' ' + notes.join(' ') : ''}`;
        usValue.textContent = match.us;
        ukValue.textContent = match.uk;
        euValue.textContent = match.eu;
      };

      function updateSizer() {
        if (!pxPerMM) {
          const stored = parseFloat(localStorage.getItem('pxPerMM') || '0');
          pxPerMM = stored > 0 ? stored : DEFAULT_PX_PER_MM;
        }
        if (!isFinite(MIN_DIAMETER_PX) || MIN_DIAMETER_PX <= 0) {
          MIN_DIAMETER_PX = MIN_DIAMETER_MM * pxPerMM;
        }
        if (!isFinite(MAX_DIAMETER_PX) || MAX_DIAMETER_PX <= 0) {
          MAX_DIAMETER_PX = MAX_DIAMETER_MM * pxPerMM;
        }

        // clamp to both min and max (and stage)
        diameterPx = Math.max(hardMinPx(), Math.min(hardMaxPx(), diameterPx));

        sizerEl.style.width  = diameterPx + 'px';
        sizerEl.style.height = diameterPx + 'px';

        window._updateDiameterLine();
      }

      // ===== Step switching =====
      function goStep(n) {
        document.getElementById('step1').style.display = (n === 1 ? 'block' : 'none');
        document.getElementById('step2').style.display = (n === 2 ? 'block' : 'none');
        if (n === 2) {
          if (!pxPerMM) {
            const stored = parseFloat(localStorage.getItem('pxPerMM') || '0');
            pxPerMM = stored > 0 ? stored : DEFAULT_PX_PER_MM;
          }
          MIN_DIAMETER_PX = MIN_DIAMETER_MM * pxPerMM;
          MAX_DIAMETER_PX = MAX_DIAMETER_MM * pxPerMM;
          setDefaultDiameter(18);
          updateSizer();
        }
      }

      document.getElementById('nextBtn1').addEventListener('click', (e) => {
        e.preventDefault();
        const renderedPx = coinCircle.getBoundingClientRect().width;
        pxPerMM = renderedPx / coinTargetMM;
        localStorage.setItem('pxPerMM', String(pxPerMM));
        goStep(2);
      });
      document.getElementById('skipBtn1').addEventListener('click', (e) => {
        e.preventDefault();
        pxPerMM = DEFAULT_PX_PER_MM;
        localStorage.setItem('pxPerMM', String(pxPerMM));
        goStep(2);
      });

      document.getElementById('nextBtn2').addEventListener('click', (e) => {
        e.preventDefault();
        const renderedPx = creditCard.getBoundingClientRect().width; // long edge
        pxPerMM = renderedPx / 85.6;
        localStorage.setItem('pxPerMM', String(pxPerMM));
        goStep(2);
      });
      document.getElementById('skipBtn2').addEventListener('click', (e) => {
        e.preventDefault();
        pxPerMM = DEFAULT_PX_PER_MM;
        localStorage.setItem('pxPerMM', String(pxPerMM));
        goStep(2);
      });

      // Drag to resize (ring) — respects min/max
      sizerEl.addEventListener('pointerdown', (e) => {
        dragging = true;
        startX = e.clientX;
        sizerEl.setPointerCapture(e.pointerId);
      });
      sizerEl.addEventListener('pointermove', (e) => {
        if (!dragging) return;
        const dx = e.clientX - startX;
        diameterPx = Math.max(hardMinPx(), Math.min(hardMaxPx(), diameterPx + dx));
        startX = e.clientX;
        updateSizer();
      });
      sizerEl.addEventListener('pointerup', () => { dragging = false; });

      // Buttons for circle (ring) — respect min/max
      document.getElementById('circleSmaller').addEventListener('click', (e) => {
        e.preventDefault();
        diameterPx = Math.max(hardMinPx(), diameterPx - 1);
        updateSizer();
      });
      document.getElementById('circleLarger').addEventListener('click', (e) => {
        e.preventDefault();
        diameterPx = Math.min(hardMaxPx(), diameterPx + 1);
        updateSizer();
      });
      document.getElementById('reset18').addEventListener('click', (e) => {
        e.preventDefault();
        setDefaultDiameter(18);
        updateSizer();
      });

      // Keep the limits correct on resize/orientation changes
      new ResizeObserver(() => {
        updateSizer();
      }).observe(sizerArea);

      // Initial paint for coin UI
      renderCoinUI();
      function renderCoinUI() {
        [...coinSelector.querySelectorAll('button')].forEach(btn => {
          const mm = parseFloat(btn.dataset.mm);
          btn.classList.toggle('active', Math.abs(mm - coinTargetMM) < 0.001);
        });
        coinCircle.style.width = coinPx + 'px';
        coinCircle.style.height = coinPx + 'px';
      }
    });
  </script>
</body>
</html>
